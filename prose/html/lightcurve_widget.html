<script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/underscore@1.13.1/underscore-umd-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
<script src="https://unpkg.com/feather-icons"></script>

<!-- Functions for plotting and binning -->
<!-- ---------------------------------- -->
<script>
    // Arithmetic mean
    function getMean(data) {
        if (data.length != 0) {
            return data.reduce(function (a, b) {
                return Number(a) + Number(b);
            }) / data.length;
        } else {
            return undefined
        }

    };

    // Standard deviation
    function getStd(data) {
        let m = getMean(data);
        return Math.sqrt(data.reduce(function (sq, n) {
            return sq + Math.pow(n - m, 2);
        }, 0) / data.length);
    };

    // Array min and max
    function getMinMax(data) {
        return [Math.min(...data), Math.max(...data)]
    }

    // SigmaCliping
    function sigClipStd(x, factor = 3.0) {
        mean = getMean(x)
        std = getStd(x)
        return getStd(x.filter(el => Math.abs(el - mean) / std < factor))
    }

    // Data binning
    function binn(x, y, bins = 0.005) {
        let [min_bin, max_bin] = getMinMax(x)

        var binned_y = [], binned_std = [], binned_x = []

        let cbin = min_bin
        let x_entries = Array.from(x.entries())

        while (cbin < max_bin + bins) {
            let new_bin = cbin + bins
            let bin_index = []
            for (let [i, j] of x_entries) {
                if (j >= cbin && j < new_bin) { bin_index.push(i) }
            }

            _lc = y.slice(Math.min(...bin_index), Math.max(...bin_index) + 1)
            bin_index.forEach(i => x_entries.splice(i, 1))

            binned_y.push(getMean(_lc))
            binned_std.push(getStd(_lc) / Math.sqrt(_lc.length))
            binned_x.push(cbin + bins / 2)

            cbin = new_bin
        }

        return [binned_x, binned_y, binned_std]
    }

    var axis = {
        zeroline: false,
        showline: true,
        mirror: true,
        linecolor: "white",
        tickcolor: "white",
        gridcolor: 'whitesmoke',
        ticks: 'inside',
    }


    var plotlyLayout_small = {
        width: 350, height: 110,
        margin: {
            l: 40, r: 15, b: 20, t: 20, pad: 0
        },
        xaxis: axis,
        yaxis: axis,
        font: {
            family: 'Arial Black',
            size: 8,
            color: 'rgba(255,255,255,0.7)'
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        showlegend: false
    }

    var black = '#A4A3A4'

    function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)] : null;
    }

    function standardize_color(str, opacity) {
        var ctx = document.createElement("canvas").getContext("2d")
        ctx.fillStyle = str
        return `rgba(${hexToRgb(ctx.fillStyle).join(",")},${opacity})`
    }

    function xaxis_style(xlim) {
        return Object.assign({
            mirror: true,
            title: {
                text: 'time',
                font: {
                    size: 10,
                    color: black
                }
            },
            range: xlim,
        }, axis)
    }

    function yaxis_style(title, ylim = undefined) {
        return Object.assign({
            range: ylim,
            autorange: ylim === undefined,
            title: {
                text: title,
                font: {
                    size: 10,
                    color: black
                }
            },
        }, axis)
    }


    function lc_layout(range, max_obs = undefined, transit_windows = undefined, ylim = undefined, xaxis = true) {

        if (max_obs != undefined) {
            center = (range[1] - range[0]) / 2 + range[0]
            range = [center - (max_obs / 2), center + (max_obs / 2)]
        }

        var shapes = []

        if (transit_windows !== undefined) {
            transit_windows.forEach(function (transit) {
                let [t0, duration, period, color] = transit
                let n_p = Math.floor((range[1] - t0) / period)

                if (
                    Math.floor((range[0] - t0) / period) <= n_p &&
                    n_p <= Math.floor((range[1] - t0) / period)
                ) {
                    shapes.push({
                        type: 'rect',
                        // x-reference is assigned to the x-values
                        xref: 'x',
                        // y-reference is assigned to the plot paper [0,1]
                        yref: 'paper',
                        x0: n_p * period + t0 - (duration / 48),
                        y0: 0,
                        x1: n_p * period + t0 + (duration / 48),
                        y1: 1,
                        fillcolor: color,
                        line: {
                            width: 0,
                        },
                        opacity: 0.05,
                        layer: "below",
                    })
                    shapes.push({
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: n_p * period + t0 - duration / 48,
                        x1: n_p * period + t0 - duration / 48,
                        y1: 1,
                        y0: 0,
                        line: {
                            color: color,
                            width: 1.5,
                        },
                        opacity: 0.3,
                        layer: "below",
                    })
                    shapes.push({
                        type: 'line',
                        xref: 'x',
                        yref: 'paper',
                        x0: n_p * period + t0 + duration / 48,
                        x1: n_p * period + t0 + duration / 48,
                        y1: 1,
                        y0: 0,
                        line: {
                            color: color,
                            width: 1.5,
                        },
                        opacity: 0.3,
                        layer: "below",
                    })
                }
            })
        }

        return _.clone(plotlyLayout_small), {
            width: undefined, height: undefined,
            font: {
                family: 'Arial',
                size: 10,
                color: '#000000'
            },
            yaxis: {
                linecolor: black,
                tickcolor: black,
                gridcolor: 'whitesmoke',
                range: ylim,
                zeroline: false,
                mirror: true,
                autorange: ylim === undefined,
                title: {
                    text: 'Relative flux',
                    font: {
                        size: 10,
                        color: black
                    }
                },
                ticks: 'inside',
            },
            xaxis: {
                linecolor: black,
                tickcolor: black,
                gridcolor: 'whitesmoke',
                mirror: true,
                title: {
                    text: 'time',
                    font: {
                        size: 10,
                        color: black
                    }
                },
                range: range,
                ticks: 'inside',
            },
            margin: {
                l: 25, r: 15, b: 30, t: 10, pad: 0
            },
            showlegend: false,
            autosize: true,
            shapes: shapes
        }
    }

    var plotlyOptions = {
        displayModeBar: false,
        displaylogo: false,
        responsive: true
    }

    // used
    function traces(x, y, bins, color, i = undefined) {
        let trace = {
            x: x,
            y: y,
            xaxis: "x",
            yaxis: "y" + (i | ""),
            mode: 'markers',
            marker: { color: 'rgba(0,0,0, 0.1)', size: 4 },
            hoverinfo: "x",
        }

        var [binned_x, binned_y, binned_error] = binn(x, y, bins = bins)

        let binned_trace = {
            x: binned_x,
            y: binned_y,
            xaxis: "x",
            yaxis: "y" + (i | ""),
            error_y: {
                type: 'data',
                array: binned_error,
                visible: true,
                thickness: 1,
                width: 2,
            },
            mode: 'markers',
            marker: { color: color, size: 4.5 },
            hoverinfo: "x",

        }

        return [trace, binned_trace]

    }


    function plot(x, y, id, bins = 0.005, color = '#4B88C2') {

        let data = traces(x, y, bins, color)
        layout = lc_layout(getMinMax(x), undefined, [], ylim = undefined)

        layout.xaxis.spikemode = 'across'
        layout.xaxis.spikedash = 'solid'
        layout.xaxis.spikesnap = 'cursor'
        layout.xaxis.spikethickness = 1
        layout.spikedistance = -1
        layout.yaxis.title = undefined

        Plotly.react(id, data, layout, plotlyOptions)
    }
</script>
<script>console.log("hello")</script>

<div id="prose__divid__">
    <div class="lc-plot" style="width: __width__px">
        <div id="__divid__" class="plot"></div>
        <div class="header">
            <div class="lc-interact">
                <div v-on:click="reset()" v-tooltip.top="'reset'">
                    <i class="reload-icon clickable" data-feather="refresh-cw"></i>
                </div>
                <div class="spiner-box">
                    <div class="spinner-header">aperture</div>
                    <input ref="ap" class="spinner" type="number" name="quantity"
                        :min="Math.min(...apertures.map(x=>+x))" :max="Math.max(...apertures.map(x=>+x))"
                        v-model.number="aperture" step="1" @change="plot_lc()"
                        :style="{'text-decoration': (aperture == best)?'underline':'none' }">
                </div>
                <div class="spiner-box">
                    <div class="spinner-header">binning</div>
                    <input class="spinner" type="number" name="quantity" min="0.001" max="0.05" value="0.005"
                        step="0.001" v-model.number="binning" @change="plot_lc()" />
                </div>
            </div>
        </div>
    </div>
</div>
</div>

<style>
    .lc-plot {
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .lc-plot .plot {
        height: 350px;
    }

    .lc-plot .header {
        display: flex;
        flex-direction: row;
        justify-content: flex-end;
        padding: 0px 10px 0px 20px;
        position: relative;
    }

    .lc-plot .lc-interact {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        opacity: 1
    }

    .reload-icon {
        width: 20px;
        height: 20px;
        margin: 0px 6px 0px 0px;
    }

    .clickable {
        cursor: pointer;
    }

    .clickable:hover {
        text-decoration: underline;
    }

    .spinner {
        height: 25px;
        border-radius: 4px;
        border: 1px solid lightgrey;
        width: 50px;
        text-align: right;
        margin-right: 5px;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 11px;
        font-weight: 400;
        color: #888888;
        outline: none;
    }

    .spiner-box {
        position: relative;
    }

    .spinner-header {
        font-size: 12px;
        color: lightgrey;
        width: 100%;
        text-align: center;
    }

    .feather {
        stroke: DarkGray;
        width: 20px;
        height: 20px;
        margin: 0px 3px 0px 3px;
    }
</style>

<script>
    var __divid__ = new Vue({
        el: '#prose__divid__',
        data: {
            fluxes: __fluxes__,
            time: __time__,
            best: __best__,
            apertures: __apertures__,
            divid: '__divid__',

            aperture: undefined,
            binning: 0.005,
        },
        mounted: function () {
            feather.replace()
            this.reset()
        },
        methods: {
            reset: function () {
                this.aperture = this.best
                this.binning = 0.005
                this.plot_lc()
            },
            plot_lc: function (aperture = this.aperture, binning = this.binning) {
                plot(this.time, this.fluxes[aperture], this.divid, binning, color = "black")
            },
        }
    })
</script>